1. Project Overview
UrbanEye is a modern, cross-platform mobile application designed to empower citizens by enabling them to report civic issues seamlessly. Users can capture or upload a photo of an issue (like a pothole, broken streetlight, or waste overflow), provide a brief description, and submit it.

The application leverages Google's Gemini AI to automatically generate a concise, official summary of the issue from the user's description. All data, including user information, issue reports, and images, is securely managed by a Supabase backend. The frontend is built with React Native and Expo (SDK 53), ensuring a smooth and performant user experience on both iOS and Android. This document details the project's architecture, setup, and core functionalities using a TypeScript-based stack.

2. Technology Stack
The project is built using a modern, scalable, and type-safe technology stack.

Frontend: React Native with Expo SDK 53, TypeScript

Navigation: Expo Router (File-based routing)

UI Components: React Native Elements (or a similar UI library)

Backend-as-a-Service (BaaS): Supabase (PostgreSQL Database, Authentication, Storage)

AI Integration: Google Generative AI (Gemini API) for text summarization

Environment Management: react-native-dotenv

3. Project Architecture
The project is organized into two primary directories: frontend for the React Native application and backend for Supabase configuration instructions.

UrbanEye/
├── backend/
│   └── supabase_setup.md   # SQL schema and setup instructions
│
└── frontend/
    ├── app/                  # Expo Router directory
    │   ├── (tabs)/           # Layout for tab navigation
    │   │   ├── _layout.tsx   # Tab navigator configuration
    │   │   ├── home.tsx      # Home screen (issue feed)
    │   │   ├── report.tsx    # Report new issue screen
    │   │   └── profile.tsx   # User profile and logout screen
    │   ├── _layout.tsx       # Root stack navigator layout
    │   └── index.tsx         # Entry screen (Splash/Authentication)
    │
    ├── components/           # Reusable UI components (e.g., CustomButton.tsx)
    │
    ├── lib/                  # Library for client configurations
    │   ├── gemini.ts         # Gemini AI client and helper functions
    │   └── supabase.ts       # Supabase client initialization
    │
    ├── .env                  # Environment variables (API keys)
    ├── package.json
    └── tsconfig.json
4. Backend Setup (Supabase)
The backend is fully managed by Supabase. Follow the instructions in backend/supabase_setup.md.

4.1. Project Creation
Navigate to supabase.com and create a new project named urbaneye.

Store the Project URL and anon (public) key securely. These will be used in the frontend's .env file.

4.2. Database Schema
A single primary table, issues, will store all reports. Use the SQL Editor in the Supabase dashboard to run the following schema definition.

SQL

-- Create the issues table to store all reports
CREATE TABLE public.issues (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  issue_type TEXT NOT NULL,
  user_description TEXT,
  ai_description TEXT, -- Populated by Gemini AI
  image_url TEXT NOT NULL,
  latitude DOUBLE PRECISION,
  longitude DOUBLE PRECISION,
  status TEXT DEFAULT 'reported' NOT NULL -- e.g., 'reported', 'in_progress', 'resolved'
);

-- Enable Row Level Security
ALTER TABLE public.issues ENABLE ROW LEVEL SECURITY;

-- Define RLS Policies for secure data access
-- Policy: Allow authenticated users to insert their own issues.
CREATE POLICY "Allow users to insert their own issues"
ON public.issues FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- Policy: Allow all users to view all reported issues.
CREATE POLICY "Allow all users to view issues"
ON public.issues FOR SELECT
USING (true);
4.3. Storage Setup
Navigate to the Storage section in the Supabase dashboard.

Create a new public bucket named issue_images. This bucket will store all user-uploaded photos related to the reported issues.

5. Frontend Implementation Plan (React Native)
The frontend will be developed using the Expo framework with TypeScript for robust, type-safe code.

5.1. Project Initialization & Dependencies
Initialize the project using the Expo CLI with the TypeScript tabs template.

Bash

# Initialize a new Expo project with TypeScript
npx create-expo-app@latest frontend --template tabs-typescript

# Navigate into the project directory
cd frontend

# Install core dependencies
npx expo install @supabase/supabase-js react-native-url-polyfill @react-navigation/native expo-router react-native-screens react-native-safe-area-context

# Install feature-specific dependencies
npx expo install expo-camera expo-image-picker @google/generative-ai expo-constants react-native-elements

# Install environment variable handler
npm install react-native-dotenv
5.2. Environment Configuration
Create a .env file in the frontend root to securely store API keys and project URLs.

.env

SUPABASE_URL="YOUR_SUPABASE_PROJECT_URL"
SUPABASE_ANON_KEY="YOUR_SUPABASE_ANON_PUBLIC_KEY"
GEMINI_API_KEY="YOUR_GEMINI_API_KEY"
5.3. Core Feature Flow
Screen 1: Authentication (app/index.tsx)
Purpose: Serves as the app's entry point, acting as a splash screen and authentication hub.

UI: A clean, professional UI with the "UrbanEye" logo, a tagline, and input fields for email and password. Buttons for "Login" and "Sign Up".

Functionality:

Manages user authentication state using Supabase Auth.

Handles sign-in and sign-up logic.

If a user session exists, it automatically redirects to the home screen.

Screen 2: Home Feed (app/(tabs)/home.tsx)
Purpose: To display a real-time feed of all reported civic issues.

UI: A scrollable list of cards. Each card represents a reported issue and contains:

The issue image.

The issue type (e.g., "Pothole").

The AI-generated description.

The current status of the report.

Functionality:

On load, fetches and displays all records from the issues table in Supabase.

Implements a pull-to-refresh mechanism to fetch the latest data.

Includes a floating action button to navigate to the report screen.

Screen 3: Report Issue (app/(tabs)/report.tsx)
Purpose: The primary screen for users to create and submit a new issue report.

UI: A structured form containing:

An image preview area.

Buttons for "Take Photo" (using expo-camera) and "Upload from Gallery" (using expo-image-picker).

A text input for the "Type of Issue".

A multiline text area for the user's detailed "Description".

A "Submit Report" button.

Functionality:

User selects or captures an image and fills out the form.

On submission, a loading indicator is displayed.

The user's description is sent to the Gemini API via the helper function in lib/gemini.ts to generate a summary.

The selected image is uploaded to the issue_images bucket in Supabase Storage.

A new record containing the user's ID, form data, the public URL of the uploaded image, and the AI-generated description is inserted into the issues table.

Upon success, the user is navigated back to the home screen, and a confirmation message is shown.

Screen 4: User Profile (app/(tabs)/profile.tsx)
Purpose: To provide users with access to their account information and a way to log out.

UI: A simple screen displaying the user's email address and a prominent "Logout" button.

Functionality:

Fetches and displays the current user's email from Supabase Auth.

The "Logout" button calls supabase.auth.signOut() and redirects the user back to the authentication screen (app/index.tsx).